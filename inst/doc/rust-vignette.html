<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Paul Northrop" />

<meta name="date" content="2016-10-10" />

<title>Introducing rust: Ratio-of-Uniforms Simulation with Transformation</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Introducing rust: Ratio-of-Uniforms Simulation with Transformation</h1>
<h4 class="author"><em>Paul Northrop</em></h4>
<h4 class="date"><em>2016-10-10</em></h4>


<div id="TOC">
<ul>
<li><a href="#the-multivariate-generalized-ratio-of-uniforms-method">The multivariate generalized ratio-of-uniforms method</a><ul>
<li><a href="#example-the-multivariate-normal-distribution">Example: the multivariate normal distribution</a></li>
</ul></li>
<li><a href="#transformation-of-variable-prior-to-sampling">Transformation of variable prior to sampling</a><ul>
<li><a href="#relocation-of-the-mode-to-the-origin">Relocation of the mode to the origin</a></li>
<li><a href="#transformations-to-improve-normality-and-reduce-association">Transformations to improve normality and reduce association</a></li>
</ul></li>
<li><a href="#using-the-code">Using the code</a><ul>
<li><a href="#example-1-posterior-density-from-a-generalized-pareto-extreme-value-analysis">Example 1: posterior density from a generalized Pareto extreme value analysis</a></li>
<li><a href="#example-2-log-normal-density">Example 2: log-normal density</a></li>
<li><a href="#example-3-gamma-density">Example 3: gamma density</a></li>
<li><a href="#example-4-normal-density">Example 4: normal density</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<p>The <strong>rust</strong> package implements the multivariate generalized ratio-of-uniforms method of simulating random variates from a <span class="math inline">\(d\)</span>-dimensional continuous distribution. The user specifies (the log of) a positive target function <span class="math inline">\(f\)</span> that is proportional to the density function of the distribution.</p>
<p>The ratio-of-uniforms method has been used to simulate from low-dimensional distributions in Bayesian analyses, either as part of a Gibbs sampler, a Markov Chain Monte Carlo (MCMC) algorithm, <span class="citation">(Wakefield et al. 1994)</span> or to simulate directly from a posterior distribution <span class="citation">(Northrop, Attalides, and Jonathan 2016)</span>. <strong>rust</strong> is unlikely to be of direct use in high-dimensional problems because it’s efficiency decreases with dimension, but it may provide an alternative to MCMC methods in Bayesian analyses of models with small numbers of parameters. Potential advantages over MCMC methods are that it produces a random sample of the desired size rather than a dependent sample and avoids the need for MCMC convergence diagostics.</p>
<p>The generalized ratio-of-uniforms method is an acceptance-rejection algorithm: proposals are simulated uniformly over a <span class="math inline">\((d+1)\)</span>-dimensional region, typically a box, that bounds an acceptance region <span class="math inline">\(C(r)\)</span>, where <span class="math inline">\(r \geq 0\)</span> is a tuning parameter. The <em>probability of acceptance</em> <span class="math inline">\(p_a(d, r)\)</span>, i.e. the probability that an arbitrary proposal is accepted, is given by the ratio of the volume of <span class="math inline">\(C(r)\)</span> to the volume of the bounding region. <span class="citation">Wakefield, Gelfand, and Smith (1991)</span> suggest the strategy of relocating the mode of <span class="math inline">\(f\)</span> to the origin as a means of increasing efficiency, in the sense of increasing <span class="math inline">\(p_a(d, r)\)</span>. However, <span class="math inline">\(p_a(d, r)\)</span> may still be low even after mode relocation. In some cases it is not possible to find a simple region to bound <span class="math inline">\(C(r)\)</span>, which means that the ratio-of-uniforms method cannot be used. Transformation of variable, such as the Box-Cox family <span class="citation">(Box and Cox 1964)</span> provided in <strong>rust</strong>, can be helpful in these instances. In the multi-dimensional cases strong association between the variables tends to result in a low <span class="math inline">\(p_a(d, r)\)</span>. <strong>rust</strong> finds a rotation of variable axes that reduces the association to increase <span class="math inline">\(p_a(d, r)\)</span>. The user can also specify their own variable transformation.</p>
<p>The main function in the rust package is <code>ru</code>, which implments the generalized ratio-of-uniforms algorithm. Also provided are two functions, <code>find_lambda</code> and <code>find_lambda_one_d</code>, that may be used to set a suitable value for the parameter <code>lambda</code> if Box-Cox transformation is used prior to simulation. These are somewhat <em>ad hoc</em> but they work well on the examples studied so far. Basic plot and summary methods are also provided.</p>
<div id="the-multivariate-generalized-ratio-of-uniforms-method" class="section level2">
<h2>The multivariate generalized ratio-of-uniforms method</h2>
<p>This description follows <span class="citation">Wakefield, Gelfand, and Smith (1991)</span>. Suppose that we wish to simulate values of a <span class="math inline">\(d\)</span>-dimensional continuous random variable <span class="math inline">\(X = (X_1, \ldots, X_d)\)</span> with density function proportional to a positive integrable function <span class="math inline">\(f(x)\)</span> over a subset <span class="math inline">\(\chi\)</span> of <span class="math inline">\(\mathbb{R}^k\)</span>, where <span class="math inline">\(x =(x_1, \ldots, x_d)\)</span>. If variables <span class="math inline">\((u, v_1, \ldots, v_d)\)</span> are uniformly distributed over <span class="math display">\[ C(r) = \left\{ (u, v_1, \ldots, v_d): 0 &lt; u \leq \left[ f\left( \frac{v_1}{u^r}, \ldots, \frac{v_d}{u^r} \right) \right] ^ {1/(r d + 1)} \right\} \]</span> for some <span class="math inline">\(r \geq 0\)</span>, then <span class="math inline">\((v_1 / u ^r, \ldots, v_d / u ^ r)\)</span> has density <span class="math inline">\(f(x) / \int f(x) {\rm ~d}x\)</span>. Typically, it is not possible directly to simulate <span class="math inline">\((u, v_1, \ldots, v_d)\)</span> uniformly over <span class="math inline">\(C(r)\)</span>. Instead we simulate uniformly over a simpler region that encloses <span class="math inline">\(C(r)\)</span> accepting only those values for which the inequality in the definition of <span class="math inline">\(C(r)\)</span> holds. If, over <span class="math inline">\(\chi\)</span>, <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(x_i^{r d +1} f(x)^r\)</span>, <span class="math inline">\(i = 1, \ldots, d\)</span>, are bounded then we can enclose <span class="math inline">\(C(r)\)</span> within the <span class="math inline">\((d+1)\)</span>-dimensional bounding box <span class="math inline">\(\{ 0 &lt; u \leq a(r), \, b_i^-(r) \leq v_i \leq b_i^+(r), \, i = 1, \ldots, d \}\)</span>, where the parameters of the bounding box are given by <span class="math display">\[
\begin{eqnarray}
a(r) &amp;=&amp; \sup_\chi \, f(x)^{1 / (r d + 1)}, \\
b_i^-(r) &amp;=&amp; \inf_{\chi_i^-} \, x_i \, f(x)^{r / (r d + 1)}, \\  
b_i^+(r) &amp;=&amp; \sup_{\chi_i^+} \, x_i \, f(x)^{r / (r d + 1)},  
\end{eqnarray}
\]</span> <span class="math inline">\(\chi_i^- = \{ x \in \chi, x_i \leq 0 \}\)</span> and <span class="math inline">\(\chi_i^+ = \{ x \in \chi, x_i \geq 0 \}\)</span>. The probability of acceptance <span class="math inline">\(p_a(d, r)\)</span> of a point simulated uniformly over the bounding box is given by <span class="math display">\[ p_a(d, r) = \frac{\int f(x) {\rm ~d}x}{(r d + 1) \, a(r) \displaystyle\prod_{i=1}^d \left[b_i^+(r) -b_i^-(r) \right]}. \]</span></p>
<div id="example-the-multivariate-normal-distribution" class="section level3">
<h3>Example: the multivariate normal distribution</h3>
<p>To study how the efficiency of the ratio-of-uniforms method deceases with dimension <span class="math inline">\(d\)</span> a useful benchmark is provided by the zero-mean <span class="math inline">\(d\)</span>-dimensional normal distribution with independent components. Without loss of generality we work with the case with unit marginal variances, i.e. <span class="math display">\[ f(x) \propto \exp\left( -\frac12 \sum_{i=1}^d x_i^2 \right).\]</span></p>
<p>For all dimensions <span class="math inline">\(d\)</span> the maximal probabilty of acceptance occurs when <span class="math inline">\(r = 1/2\)</span>, giving <span class="math display">\[ p_a(d, 1/2) = \frac{(\pi e)^{d/2}}{2^d (1+d/2)^{1+d/2}}. \]</span> The maximal probabilty of acceptance decreases rapidly with <span class="math inline">\(d\)</span>, as the following table shows.</p>
<table>
<caption><span class="math inline">\(p_a(d, 1/2)\)</span> as <span class="math inline">\(d\)</span> varies.</caption>
<thead>
<tr class="header">
<th align="right">1</th>
<th align="right">2</th>
<th align="right">3</th>
<th align="right">4</th>
<th align="right">5</th>
<th align="right">6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0.795</td>
<td align="right">0.534</td>
<td align="right">0.316</td>
<td align="right">0.169</td>
<td align="right">0.083</td>
<td align="right">0.038</td>
</tr>
</tbody>
</table>
<p>It can be shown that introducing any correlation between the components reduces <span class="math inline">\(p_a(d, r)\)</span>. Later we consider using transformations to make the target density function closer to that of a <span class="math inline">\(d\)</span>-dimensional normal distribution with independent components. The closeness of the probability of acceptance that we achieved after doing this is a measure of how successful we have been.</p>
</div>
</div>
<div id="transformation-of-variable-prior-to-sampling" class="section level2">
<h2>Transformation of variable prior to sampling</h2>
<div id="relocation-of-the-mode-to-the-origin" class="section level3">
<h3>Relocation of the mode to the origin</h3>
<p><span class="citation">Wakefield, Gelfand, and Smith (1991)</span> consider the strategy of shifting the location of the target function <span class="math inline">\(f\)</span> towards the original prior to sampling, that is, we simulate <span class="math inline">\(y\)</span> from the distribution of <span class="math inline">\(Y = X-\mu\)</span> and then transform back to the original scale using <span class="math inline">\(x = y + \mu\)</span>. They show that if, in the 1-dimensional case, <span class="math inline">\(f\)</span> is unimodal and symmetric choosing <span class="math inline">\(\mu\)</span> to be the mode of <span class="math inline">\(f\)</span> maximizes <span class="math inline">\(p_a(1, r)\)</span> for all <span class="math inline">\(r\)</span>. Their proof extends to the multivariate case: mode relocation is optimal for unimodal <span class="math inline">\(d\)</span>-dimensional densities for which all the marginal densities are symmetric.</p>
<p><span class="citation">Wakefield, Gelfand, and Smith (1991)</span> suggest mode relocation and use of <span class="math inline">\(r = 1/2\)</span> as a good general strategy when <span class="math inline">\(f\)</span> is approximately unimodal. For this reason, and because experience suggests that this produces greater numerical stability in finding the bounding box parameters, the <code>ru</code> function in <strong>rust</strong> is hard-wired always to use mode relocation. The mode of the target function is relocated to the origin <em>after</em> any user-supplied transformation and/or Box-Cox transformation and <em>before</em> any rotation of axes. The default value of <span class="math inline">\(r\)</span> is <span class="math inline">\(1/2\)</span> but the user can change this.</p>
</div>
<div id="transformations-to-improve-normality-and-reduce-association" class="section level3">
<h3>Transformations to improve normality and reduce association</h3>
<p>The general idea is the same as mode relocation, i.e. to simulate from the distribution of some transformation of the original variable and transform the simulated values back to the original scale. Our aim is to use a transformation for which the transformed variable is closer than the original to being a <span class="math inline">\(d\)</span>-dimensional normal distribution with independent components. The table above gives us an indication of the best probability of acceptance we can hope to achieve for a given <span class="math inline">\(d\)</span>. Thus, we may be able to increase the probability of acceptance. In some examples, the original density is not suitable for the ratio-of-uniforms method because it is not possible to enclose <span class="math inline">\(C(r)\)</span> within a bounding box, perhaps because the density is unbounded. It may be that a transformation of variable produces a bounded density for which a bounding box be constructed.</p>
<p>From now on we denote the target variable as <span class="math inline">\(\theta = (\theta_1, \ldots, \theta_d)\)</span>. We consider a sequence of four transformations: from <span class="math inline">\(\theta\)</span> to <span class="math inline">\(\phi\)</span>; from <span class="math inline">\(\phi\)</span> to <span class="math inline">\(\psi\)</span>; mode relocation on the <span class="math inline">\(\psi\)</span>-scale; and from (mode relocated) <span class="math inline">\(\psi\)</span> to <span class="math inline">\(\rho\)</span>.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\phi=\phi(\theta)\)</span> is a user-defined transformation that could be used to ensure that all components of <span class="math inline">\(\phi\)</span> are positive prior to a Box-Cox transformation.</li>
<li><span class="math inline">\(\psi=\psi(\phi)\)</span> performs Box-Cox transformations on the margins, i.e. for <span class="math inline">\(i=1, \ldots, d\)</span>, <span class="math inline">\(\psi_i = g_i \log(\phi_i)\)</span> for <span class="math inline">\(\lambda_i = 0\)</span> and <span class="math inline">\(\displaystyle\psi_i = \frac{\phi_i^{\lambda_i} - 1}{\lambda_i g_i^{\lambda_i-1}}\)</span>, for <span class="math inline">\(\lambda_i \neq 0\)</span>.</li>
<li>Mode relocation means transforming from <span class="math inline">\(\psi\)</span> to <span class="math inline">\(\psi - \hat{\psi}\)</span>, where <span class="math inline">\(\hat{\psi}\)</span> is the estimated mode on the <span class="math inline">\(\psi\)</span>-scale.</li>
<li><span class="math inline">\(\rho=\rho(\psi - \hat{\psi})\)</span> is a rotation of axes, performed <em>after</em> mode relocation, so that the mode of the density stays at the origin. This is only relevant for <span class="math inline">\(d &gt; 1\)</span>. The transformation is <span class="math inline">\(\rho = (\psi - \hat{\psi}) L / \det(L)^{1/d}\)</span>, where <span class="math inline">\(L L^T = \hat{H}\)</span> is the estimated Hessian of the negated log-density for <span class="math inline">\(\psi\)</span>, evaluated at <span class="math inline">\(\hat{\psi}\)</span>. <code>optimHess</code> is used to estimate the Hessian and <code>chol</code> is used to calculate <span class="math inline">\(L\)</span> using the Choleski decomposition. The effect of this transformation is to produce a log-density for <span class="math inline">\(\rho\)</span> whose Hessian is diagonal at its mode. Using this orthogonalizing transformation will tend to mean that the components of <span class="math inline">\(\rho\)</span> are more weakly associated than the components of <span class="math inline">\(\psi\)</span>.</li>
</ol>
<p>We denote the resulting density as <span class="math inline">\(f_\rho\!(\rho)\)</span>. It may be that we only use a subset of these transformations. To perform only axis rotation we use identity functions <span class="math inline">\(\phi(\theta) = \theta\)</span> and <span class="math inline">\(\psi(\phi) = \phi\)</span>. If we wish to use a Box-Cox transformation and all components of <span class="math inline">\(\theta\)</span> are positive then we may use <span class="math inline">\(\phi(\theta) = \theta\)</span>.</p>
<p>To define <span class="math inline">\(\psi(\phi)\)</span> the user can set the Box-Cox parameter <span class="math inline">\(\lambda = (\lambda_1, \ldots, \lambda_d)\)</span> (and perhaps <span class="math inline">\(g = (g_1, \ldots, g_d))\)</span> by hand in a call to <code>ru</code>. Alternatively, these parameters can be set in a (somewhat) automatic way using a call to <code>find_lambda_one_d</code> (<span class="math inline">\(d = 1\)</span> only) or <code>find_lambda</code>. See the documentation of these functions for details.</p>
</div>
</div>
<div id="using-the-code" class="section level2">
<h2>Using the code</h2>
<p>We demonstrate how to use the code with four examples. We start with the generalized Pareto posterior example because (a) it illustrates well the effect of transformations on the density used in the ratio-of-uniforms algorithm and effects on the probability of acceptance, and (b) it is an example where the ratio-of-uniforms offers a meaningful alternative to the standard approach of using MCMC <span class="citation">(Stephenson and Ribatet 2014)</span>. The other examples are purely illustrative: there are specific algorithms that are preferable.</p>
<div id="example-1-posterior-density-from-a-generalized-pareto-extreme-value-analysis" class="section level3">
<h3>Example 1: posterior density from a generalized Pareto extreme value analysis</h3>
<p>The generalized Pareto (GP) distribution is used in extreme value analyses as a model for excesses over a high threshold. It has two parameters: a scale parameter <span class="math inline">\(\sigma\)</span> and a shape parameter <span class="math inline">\(\xi\)</span>. For <span class="math inline">\(\xi \neq 0\)</span> it has density function <span class="math inline">\(g_Z(z) = \sigma^{-1} \, \left(1 + \xi z / \sigma\right)_{+}^{-(1+1/\xi)}, \, z &gt; 0,\)</span> where <span class="math inline">\(x_+\!=\!\max(x,0)\)</span>. In the limit as <span class="math inline">\(\xi \rightarrow 0\)</span> we obtain the density of exponential distribution with mean <span class="math inline">\(\sigma\)</span>. Suppose that we have available a random sample <span class="math inline">\(z = (z_1, \ldots, z_m)\)</span> of threshold excesses. The likelihood for <span class="math inline">\(\theta = (\sigma, \xi)\)</span> is <span class="math inline">\(L(\theta; z) = \prod_{i=1}^m g_Z(z_i; \theta).\)</span></p>
<p>In a Bayesian analysis a prior density <span class="math inline">\(\pi(\theta)\)</span> is placed on <span class="math inline">\(\theta\)</span>. Information from the prior and likelihood are combined using Bayes’ theorem to form a posterior density <span class="math inline">\(\pi(\theta \mid z) \propto L(\theta; z) \pi(\theta).\)</span> The target density to be <span class="math inline">\(f(\theta) = \pi(\theta \mid z)\)</span>, which is positive for <span class="math inline">\(\sigma &gt; 0, \, \xi &gt; - \sigma / x_{(m)}\)</span>, where <span class="math inline">\(x_{(m)} = \max(z_1, \ldots, z_m)\)</span>. The particular prior density that we use here is <span class="math inline">\(\pi(\theta) \propto \sigma^{-1} \exp[-(\xi+1)], \,\sigma &gt; 0, \, \xi \geq -1\)</span> <span class="citation">(Northrop and Attalides 2016)</span>. For a review of Bayesian extreme value modelling see <span class="citation">Stephenson (2016)</span> and for an application based on the GP distribution see <span class="citation">Northrop, Attalides, and Jonathan (2016)</span>.</p>
<p>We simulate some data from a GP(1, -1/2) distribution. We choose <span class="math inline">\(\xi=-1/2\)</span> because this tends to result in a posterior distribution with strong negative posterior association between <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(\xi\)</span>, making the benefit of transformation more apparent. We also calculate some sample properties that feature in the likelihood, so that they can be passed to the log-density <code>logf</code> rather than being recalculated, and set an initial estimate at which <code>logf</code> is positive.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rust)
<span class="kw">set.seed</span>(<span class="dv">46</span>)
<span class="co"># Sample data from a GP(sigma, xi) distribution</span>
gpd_data &lt;-<span class="st"> </span><span class="kw">rgpd</span>(<span class="dt">m =</span> <span class="dv">100</span>, <span class="dt">xi =</span> -<span class="fl">0.5</span>, <span class="dt">sigma =</span> <span class="dv">1</span>)
<span class="co"># Calculate summary statistics for use in the log-likelihood</span>
ss &lt;-<span class="st"> </span><span class="kw">gpd_sum_stats</span>(gpd_data)
<span class="co"># Calculate an initial estimate</span>
init &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">mean</span>(gpd_data), <span class="dv">0</span>)</code></pre></div>
<p>We set the size of the sample required. We sample first on the <span class="math inline">\((\sigma, \xi)\)</span> scale, with mode relocation only. Then we add a rotation of the <span class="math inline">\((\sigma, \xi)\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="dv">10000</span>
<span class="co"># Mode relocation only ----------------</span>
x1 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> gpd_logpost, <span class="dt">ss =</span> ss, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> init,
  <span class="dt">lower =</span> <span class="kw">c</span>(<span class="dv">0</span>, -<span class="ot">Inf</span>), <span class="dt">rotate =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; [1] &quot;optim&quot;</span>

<span class="co"># Rotation of axes plus mode relocation ----------------</span>
x2 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> gpd_logpost, <span class="dt">ss =</span> ss, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> init,
  <span class="dt">lower =</span> <span class="kw">c</span>(<span class="dv">0</span>, -<span class="ot">Inf</span>))
<span class="co">#&gt; [1] &quot;optim&quot;</span></code></pre></div>
<p>Now we perform Box-Cox transformation. We define <span class="math inline">\(\phi_1 = \sigma, \phi_2 = \xi + \sigma / x_{(m)}\)</span>, so that the components of <span class="math inline">\(\phi=(\phi_1, \phi_2)\)</span> are positive, and set the inverse transformation <code>phi_to_theta</code> and the log-Jacobian <code>log_j</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Find initial estimates for phi = (phi1, phi2),</span>
<span class="co"># where phi1 = sigma</span>
<span class="co">#   and phi2 = xi + sigma / max(x),</span>
<span class="co"># and ranges of phi1 and phi2 over over which to evaluate the posterior to find</span>
<span class="co"># a suitable value of lambda.</span>
<span class="co">#</span>
<span class="co"># \code{gpd_init} returns estimates of phi and associated estimated standard </span>
<span class="co"># errors based on the data alone.  This gives a basis for setting </span>
<span class="co"># \code{min_phi} and \code{max_phi} provided that the prior the prior is not</span>
<span class="co"># strongly informative.</span>
temp &lt;-<span class="st"> </span><span class="kw">do.call</span>(gpd_init, ss)
min_phi &lt;-<span class="st"> </span><span class="kw">pmax</span>(<span class="dv">0</span>, temp$init_phi -<span class="st"> </span><span class="dv">2</span> *<span class="st"> </span>temp$se_phi)
max_phi &lt;-<span class="st"> </span><span class="kw">pmax</span>(<span class="dv">0</span>, temp$init_phi +<span class="st"> </span><span class="dv">2</span> *<span class="st"> </span>temp$se_phi)

<span class="co"># Set phi_to_theta() that ensures positivity of phi</span>
<span class="co"># We use phi1 = sigma and phi2 = xi + sigma / max(data)</span>
phi_to_theta &lt;-<span class="st"> </span>function(phi) <span class="kw">c</span>(phi[<span class="dv">1</span>], phi[<span class="dv">2</span>] -<span class="st"> </span>phi[<span class="dv">1</span>] /<span class="st"> </span>ss$xm)
log_j &lt;-<span class="st"> </span>function(x) <span class="dv">0</span></code></pre></div>
<p>We use <code>find_lambda</code> to set a suitable value of <span class="math inline">\(\lambda=(\lambda_1, \lambda_2)\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lambda &lt;-<span class="st"> </span><span class="kw">find_lambda</span>(<span class="dt">logf =</span> gpd_logpost, <span class="dt">ss =</span> ss, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">min_phi =</span> min_phi,
  <span class="dt">max_phi =</span> max_phi, <span class="dt">phi_to_theta =</span> phi_to_theta, <span class="dt">log_j =</span> log_j)
<span class="co">#&gt; [1] 2601    2</span>
lambda
<span class="co">#&gt; $lambda</span>
<span class="co">#&gt; [1] 0.1624226 0.3678549</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $gm</span>
<span class="co">#&gt; [1] 1.10542493 0.03225836</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $init_psi</span>
<span class="co">#&gt; [1]  0.1054021 -0.2184344</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $sd_psi</span>
<span class="co">#&gt;       Var1       Var2 </span>
<span class="co">#&gt; 0.12670792 0.02477219 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $phi_to_theta</span>
<span class="co">#&gt; function (phi) </span>
<span class="co">#&gt; c(phi[1], phi[2] - phi[1]/ss$xm)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $log_j</span>
<span class="co">#&gt; function (x) </span>
<span class="co">#&gt; 0</span></code></pre></div>
<p>We sample from the Box-Cox transformed density, first without, and then with, rotation of axes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Sample on Box-Cox transformed, without rotation</span>
x3 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> gpd_logpost, <span class="dt">ss =</span> ss, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">n =</span> n, <span class="dt">trans =</span> <span class="st">&quot;BC&quot;</span>,
  <span class="dt">lambda =</span> lambda, <span class="dt">rotate =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; [1] &quot;optim&quot;</span>

<span class="co"># Box-Cox transformation, mode relocation and rotation ----------------</span>
x4 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> gpd_logpost, <span class="dt">ss =</span> ss, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">n =</span> n, <span class="dt">trans =</span> <span class="st">&quot;BC&quot;</span>,
  <span class="dt">lambda =</span> lambda, <span class="dt">var_names =</span> <span class="kw">c</span>(<span class="st">&quot;sigma&quot;</span>, <span class="st">&quot;xi&quot;</span>))
<span class="co">#&gt; [1] &quot;optim&quot;</span></code></pre></div>
<p>We plot the samples obtained on the scales used for the ratio-of-uniforms algorithm and contours of the corresponding target density <span class="math inline">\(f_\rho\!(\rho)\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(x1, <span class="dt">ru_scale =</span> <span class="ot">TRUE</span>, <span class="dt">cex.main =</span> <span class="fl">0.75</span>, <span class="dt">cex.lab =</span> <span class="fl">0.75</span>, 
  <span class="dt">main =</span> <span class="kw">paste</span>(<span class="st">&quot;mode relocation </span><span class="ch">\n</span><span class="st"> pa = &quot;</span>, <span class="kw">round</span>(x1$pa, <span class="dv">3</span>)))
<span class="kw">plot</span>(x2, <span class="dt">ru_scale =</span> <span class="ot">TRUE</span>, <span class="dt">cex.main =</span> <span class="fl">0.75</span>, <span class="dt">cex.lab =</span> <span class="fl">0.75</span>, 
  <span class="dt">main =</span> <span class="kw">paste</span>(<span class="st">&quot;mode relocation and rotation </span><span class="ch">\n</span><span class="st"> pa = &quot;</span>, <span class="kw">round</span>(x2$pa, <span class="dv">3</span>)))
<span class="kw">plot</span>(x3, <span class="dt">ru_scale =</span> <span class="ot">TRUE</span>, <span class="dt">cex.main =</span> <span class="fl">0.75</span>, <span class="dt">cex.lab =</span> <span class="fl">0.75</span>, 
  <span class="dt">main =</span> <span class="kw">paste</span>(<span class="st">&quot;Box-Cox and mode relocation </span><span class="ch">\n</span><span class="st"> pa = &quot;</span>, <span class="kw">round</span>(x3$pa, <span class="dv">3</span>)))
<span class="kw">plot</span>(x4, <span class="dt">ru_scale =</span> <span class="ot">TRUE</span>, <span class="dt">cex.main =</span> <span class="fl">0.75</span>, <span class="dt">cex.lab =</span> <span class="fl">0.75</span>,
  <span class="dt">main =</span> <span class="kw">paste</span>(<span class="st">&quot;Box-Cox, mode relocation and rotation </span><span class="ch">\n</span><span class="st"> pa = &quot;</span>, <span class="kw">round</span>(x4$pa, <span class="dv">3</span>)))</code></pre></div>
<p><img src="data:image/png;base64,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" alt /><img src="data:image/png;base64,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" alt /><img src="data:image/png;base64,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" alt /><img src="data:image/png;base64,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" alt /></p>
<p>The figure shows how the transformations affect with shape of the density from which we simulate. In the bottom right plot the density contours suggests little dependence between the transformed components. The estimate of the probability of acceptance is approximately equal to the 0.534 obtained for a 2-dimensional normal distribution with independent components.</p>
<p>Finally, we show a plot of the sample and contours on the original <span class="math inline">\((\sigma, \xi\)</span>)-scale.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(x4, <span class="dt">xlab =</span> <span class="st">&quot;sigma&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;xi&quot;</span>)</code></pre></div>
<p><img src="data:image/png;base64,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gCdo1bOMeDXICBpbqudo5nNbfYLdPXfV9+802E3zC0hTTbGwozi8BvXaKtzUXDbadtlEN6INNVZ5w1X0gXqOF8y71Juu8uVgfbMz3+u65143wsEqgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFARIU5D30d5Lk6aghKAgQGKC9OJ48bZIsUshdv68c3736ld6uar+UfFo30VVY0hLkFmLthZvjSC97GottCCz2j67p5f06VVrq15LZseRlqByeZgWlC/cu9SCDoulZtlD9784n2BlZg/SElReaaEFFX9MUQt6WzgpxKznzLG0BKniz99pQavNglZC7P59ayPIkGVVcwT5kTQLCQrK7LgatKoIMtp6XfcxkrQEmYXD6zyCvFasEkH3x+MXr3YmLUFm5W4myfaDdv+2+12tBu2cX87XzicmqMbolfJjSVeQiZnGv7o9G+kKMuk256BiMwkLSgMKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBPg/VTd4DjOBs1sAAAAASUVORK5CYII=" style="display: block; margin: auto;" /></p>
<p>and an example of the output from <code>summary.ru</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(x4)
<span class="co">#&gt; sample summary </span>
<span class="co">#&gt;      sigma              xi         </span>
<span class="co">#&gt;  Min.   :0.7156   Min.   :-0.9428  </span>
<span class="co">#&gt;  1st Qu.:1.0228   1st Qu.:-0.6205  </span>
<span class="co">#&gt;  Median :1.1088   Median :-0.5617  </span>
<span class="co">#&gt;  Mean   :1.1160   Mean   :-0.5606  </span>
<span class="co">#&gt;  3rd Qu.:1.2004   3rd Qu.:-0.5023  </span>
<span class="co">#&gt;  Max.   :1.7745   Max.   :-0.1537  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; estimated probability of acceptance:  </span>
<span class="co">#&gt; [1] 0.5319432</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; ru bounding box:  </span>
<span class="co">#&gt;                 box        vals1        vals2 conv</span>
<span class="co">#&gt; a        1.00000000  0.000000000  0.000000000    0</span>
<span class="co">#&gt; b1minus -0.06636547 -0.107225819  0.006573398    0</span>
<span class="co">#&gt; b2minus -0.06756121 -0.001105787 -0.107428499    0</span>
<span class="co">#&gt; b1plus   0.07292561  0.123468775  0.005092513    0</span>
<span class="co">#&gt; b2plus   0.06961246 -0.003093026  0.115104329    0</span></code></pre></div>
</div>
<div id="example-2-log-normal-density" class="section level3">
<h3>Example 2: log-normal density</h3>
<p>If <span class="math inline">\(X\)</span> has a log-normal distribution with parameters <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span> then <span class="math inline">\(Z = \log X\)</span> has a normal distributon with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span>. Therefore, we know that a log transformation, i.e. a Box-Cox transformation with <span class="math inline">\(\lambda =0\)</span>, produces exact normality and we find that the estimated probability of acceptance if greater when when transform than when we don’t.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Sampling on original scale ----------------</span>
x1 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> dlnorm, <span class="dt">log =</span> <span class="ot">TRUE</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">lower =</span> <span class="dv">0</span>, <span class="dt">init =</span> <span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;nlminb&quot;</span>
x1$pa
<span class="co">#&gt; [1] 0.5740858</span>
<span class="kw">summary</span>(x1)
<span class="co">#&gt; sample summary </span>
<span class="co">#&gt;        V1          </span>
<span class="co">#&gt;  Min.   : 0.01584  </span>
<span class="co">#&gt;  1st Qu.: 0.52102  </span>
<span class="co">#&gt;  Median : 1.02848  </span>
<span class="co">#&gt;  Mean   : 1.64284  </span>
<span class="co">#&gt;  3rd Qu.: 1.95576  </span>
<span class="co">#&gt;  Max.   :30.91191  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; estimated probability of acceptance:  </span>
<span class="co">#&gt; [1] 0.5740858</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; ru bounding box:  </span>
<span class="co">#&gt;                box      vals1 conv</span>
<span class="co">#&gt; a        1.0000000  0.0000000    0</span>
<span class="co">#&gt; b1minus -0.2023271 -0.2607045    0</span>
<span class="co">#&gt; b1plus   1.5722199  8.0997951    0</span>

<span class="co"># Box-Cox transform with lambda = 0 ----------------</span>
lambda &lt;-<span class="st"> </span><span class="dv">0</span>
init &lt;-<span class="st"> </span><span class="kw">box_cox</span>(<span class="dv">1</span>, <span class="dt">lambda =</span> lambda)
x2 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> dlnorm, <span class="dt">log =</span> <span class="ot">TRUE</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> init, <span class="dt">trans =</span> <span class="st">&quot;BC&quot;</span>,
      <span class="dt">lambda =</span> lambda)
<span class="co">#&gt; [1] &quot;nlminb&quot;</span>
x2$pa
<span class="co">#&gt; [1] 0.7944074</span></code></pre></div>
<p>To show how a user could implement their own transformation prior to sampling we use the <code>trans = &quot;user&quot;</code> argument and supply the inverse Box-Cox transformation via <code>phi_to_theta</code> and the log-Jacobian via <code>log_j</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Equivalently, we could use trans = &quot;user&quot; and supply the (inverse) Box-Cox</span>
<span class="co"># transformation and the log-Jacobian by hand</span>
x3 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> dlnorm, <span class="dt">log =</span> <span class="ot">TRUE</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> init, <span class="dt">trans =</span> <span class="st">&quot;user&quot;</span>,
        <span class="dt">phi_to_theta =</span> function(x) <span class="kw">exp</span>(x), <span class="dt">log_j =</span> function(x) -<span class="kw">log</span>(x))
<span class="co">#&gt; [1] &quot;nlminb&quot;</span>
x3$pa
<span class="co">#&gt; [1] 0.7931472</span></code></pre></div>
<p>Sampling is performed using a normal density before transforming back to the log-normal scale.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(x3, <span class="dt">ru_scale =</span> <span class="ot">TRUE</span>, <span class="dt">xlab =</span> <span class="st">&quot;z&quot;</span>)
<span class="kw">plot</span>(x1, <span class="dt">xlab =</span> <span class="st">&quot;x&quot;</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" alt /><img src="data:image/png;base64,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" alt /></p>
<p>We could also use <code>find_lambda_one_d</code> to estimate a suitable value of <span class="math inline">\(\lambda\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Note: the default value of max_phi = 10 is OK here but this will not always be the case.</span>
lambda &lt;-<span class="st"> </span><span class="kw">find_lambda_one_d</span>(<span class="dt">logf =</span> dlnorm, <span class="dt">log =</span> <span class="ot">TRUE</span>)
lambda
<span class="co">#&gt; $lambda</span>
<span class="co">#&gt; [1] 0.06371055</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $gm</span>
<span class="co">#&gt; [1] 0.9536964</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $init_psi</span>
<span class="co">#&gt; [1] -0.06346005</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $sd_psi</span>
<span class="co">#&gt; [1] 0.9753502</span></code></pre></div>
<p>We get a value of <span class="math inline">\(\lambda\)</span> that is close to zero and an estimated probability of acceptance that is similar to before.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x4 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> dlnorm, <span class="dt">log =</span> <span class="ot">TRUE</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">trans =</span> <span class="st">&quot;BC&quot;</span>, <span class="dt">lambda =</span> lambda)
<span class="co">#&gt; [1] &quot;nlminb&quot;</span>
x4$pa
<span class="co">#&gt; [1] 0.791703</span></code></pre></div>
</div>
<div id="example-3-gamma-density" class="section level3">
<h3>Example 3: gamma density</h3>
<p>The gamma distribution, with shape parameter <span class="math inline">\(\alpha\)</span>, provides a useful example because when <span class="math inline">\(\alpha &lt; 1\)</span> the gamma density is not bounded above. Therefore the ratio-of-uniforms cannot be used unless we use transformation to avoid this. Even if <span class="math inline">\(\alpha \geq 1\)</span> we can improve the probability of acceptance by transforming to approximate normality using a cube root transformation <span class="citation">(Wilson and Hilferty 1931)</span>, i.e. a Box-Cox transformation with <span class="math inline">\(\lambda = 1/3\)</span>. We illustrate this for <span class="math inline">\(\alpha = 1\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">alpha &lt;-<span class="st"> </span><span class="dv">1</span>
x1 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> dgamma, <span class="dt">shape =</span> alpha, <span class="dt">log =</span> <span class="ot">TRUE</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">lower =</span> <span class="dv">0</span>,
       <span class="dt">init =</span> alpha)
<span class="co">#&gt; [1] &quot;nlminb&quot;</span>
<span class="co">#&gt; Warning in ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = n, lower = 0, : The Hessian of the target log-density at its mode is not positive</span>
<span class="co">#&gt;             definite. This may not be a problem, but it may be that a mode</span>
<span class="co">#&gt;             at/near a parameter boundary has been found and/or that the target</span>
<span class="co">#&gt;             function is unbounded.</span>
<span class="co">#&gt;   It might be worth using the option trans = ``BC''.</span>
x1$pa
<span class="co">#&gt; [1] 0.6044122</span></code></pre></div>
<p>We get a warning because when <span class="math inline">\(\alpha = 1\)</span> the mode of a gamma distribution is at zero, the lower end point of the distribution. In this example it doesn’t matter because the density is finite at the mode and we are not relying on the mode being at a turning point of the density. However, if we are using rotation of axes in a multidimensional example then we may have a problem because the rotation is based on an estimate of the Hessian of the density at the mode.</p>
<p>Now we use a cube root transformation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Box-Cox transform with lambda = 1/3 works well for shape &gt;= 1. -----------</span>
x2 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> dgamma, <span class="dt">shape =</span> alpha, <span class="dt">log =</span> <span class="ot">TRUE</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">trans =</span> <span class="st">&quot;BC&quot;</span>,
       <span class="dt">lambda =</span> <span class="dv">1</span>/<span class="dv">3</span>, <span class="dt">init =</span> alpha)
<span class="co">#&gt; [1] &quot;nlminb&quot;</span>
x2$pa
<span class="co">#&gt; [1] 0.7937768</span></code></pre></div>
<p>Again we show how <code>trans = &quot;user&quot;</code> can be used to use user-defined tranformation, this time supplying the value of <span class="math inline">\(\lambda\)</span> using <code>user_args</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Equivalently, we could use trans = &quot;user&quot; and supply the (inverse) Box-Cox</span>
<span class="co"># transformation and the log-Jacobian by hand</span>
<span class="co"># Note: when phi_to_theta is undefined at x this function returns NA</span>
phi_to_theta  &lt;-<span class="st"> </span>function(x, lambda) {
  <span class="kw">ifelse</span>(x *<span class="st"> </span>lambda +<span class="st"> </span><span class="dv">1</span> &gt;<span class="st"> </span><span class="dv">0</span>, (x *<span class="st"> </span>lambda +<span class="st"> </span><span class="dv">1</span>) ^<span class="st"> </span>(<span class="dv">1</span> /<span class="st"> </span>lambda), <span class="ot">NA</span>)
}
log_j &lt;-<span class="st"> </span>function(x, lambda) (lambda -<span class="st"> </span><span class="dv">1</span>) *<span class="st"> </span><span class="kw">log</span>(x)
lambda &lt;-<span class="st"> </span><span class="dv">1</span>/<span class="dv">3</span>
x3 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> dgamma, <span class="dt">shape =</span> alpha, <span class="dt">log =</span> <span class="ot">TRUE</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">trans =</span> <span class="st">&quot;user&quot;</span>,
       <span class="dt">phi_to_theta =</span> phi_to_theta, <span class="dt">log_j =</span> log_j, <span class="dt">user_args =</span> <span class="kw">list</span>(<span class="dt">lambda =</span> lambda),
       <span class="dt">init =</span> alpha)
<span class="co">#&gt; [1] &quot;nlminb&quot;</span>
x3$pa
<span class="co">#&gt; [1] 0.7968127</span></code></pre></div>
<p>We could also use <code>find_lambda_one_d</code> to set <span class="math inline">\(\lambda\)</span>: see the examples in the documentation for <code>find_lambda_one_d</code> for details.</p>
<p>For <span class="math inline">\(\alpha &lt; 1\)</span> the gamma density is very skewed and the density increases without limit at the origin. A cube root transformation tends not to be sufficiently strong to produce a distribution for which the density is finite at its mode. We use <code>find_lambda_one_d</code> to estimate a suitable value of <span class="math inline">\(\lambda\)</span>. We need to set a range of values over which to evaluate the gamma density in order to estimate <span class="math inline">\(\lambda\)</span>. Here we cheat by using the gamma quantile function, something that wouldn’t usually be available.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">alpha &lt;-<span class="st"> </span><span class="fl">0.1</span>
<span class="co"># Choose a sensible value of max_phi</span>
max_phi &lt;-<span class="st"> </span><span class="kw">qgamma</span>(<span class="fl">0.999</span>, <span class="dt">shape =</span> alpha)
<span class="co"># [I appreciate that typically the quantile function won't be available.</span>
<span class="co"># In practice the value of lambda chosen is quite insensitive to the choice</span>
<span class="co"># of max_phi, provided that max_phi is not far too large or far too small.]</span>
max_phi &lt;-<span class="st"> </span><span class="kw">qgamma</span>(<span class="fl">0.999</span>, <span class="dt">shape =</span> alpha)
lambda &lt;-<span class="st"> </span><span class="kw">find_lambda_one_d</span>(<span class="dt">logf =</span> dgamma, <span class="dt">shape =</span> alpha, <span class="dt">log =</span> <span class="ot">TRUE</span>,
  <span class="dt">max_phi =</span> max_phi)
lambda
<span class="co">#&gt; $lambda</span>
<span class="co">#&gt; [1] 0.06777767</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $gm</span>
<span class="co">#&gt; [1] 0.008053051</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $init_psi</span>
<span class="co">#&gt; [1] -0.03426831</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $sd_psi</span>
<span class="co">#&gt; [1] 0.009354108</span>
x4 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> dgamma, <span class="dt">shape =</span> alpha, <span class="dt">log =</span> <span class="ot">TRUE</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">trans =</span> <span class="st">&quot;BC&quot;</span>,
  <span class="dt">lambda =</span> lambda)
<span class="co">#&gt; [1] &quot;nlminb&quot;</span>
x4$pa
<span class="co">#&gt; [1] 0.7532389</span></code></pre></div>
<p>For a value of <span class="math inline">\(\alpha\)</span> so close to 0 the density is very peaked at the origin (see the plot on the left below). After a transformation that is close to a log transformation the target density (see the plot on the right) is bounded above and the estimated probability of acceptance is simiilar to that of a normal distribution.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(x4)
<span class="kw">plot</span>(x4, <span class="dt">ru_scale =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" alt /><img src="data:image/png;base64,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" alt /></p>
</div>
<div id="example-4-normal-density" class="section level3">
<h3>Example 4: normal density</h3>
<p>We show the effects of rotation of axes for the two- and three- dimensional normal density.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># two-dimensional normal with positive association ----------------</span>
rho &lt;-<span class="st"> </span><span class="fl">0.9</span>
covmat &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, rho, rho, <span class="dv">1</span>), <span class="dv">2</span>, <span class="dv">2</span>)
log_dmvnorm &lt;-<span class="st"> </span>function(x, <span class="dt">mean =</span> <span class="kw">rep</span>(<span class="dv">0</span>, d), <span class="dt">sigma =</span> <span class="kw">diag</span>(d)) {
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(x, <span class="dt">ncol =</span> <span class="kw">length</span>(x))
  d &lt;-<span class="st"> </span><span class="kw">ncol</span>(x)
  -<span class="st"> </span><span class="fl">0.5</span> *<span class="st"> </span>(x -<span class="st"> </span>mean) %*%<span class="st"> </span><span class="kw">solve</span>(sigma) %*%<span class="st"> </span><span class="kw">t</span>(x -<span class="st"> </span>mean)
}
<span class="co"># No rotation.</span>
x1 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> log_dmvnorm, <span class="dt">sigma =</span> covmat, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>),
  <span class="dt">rotate =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; [1] &quot;optim&quot;</span>
<span class="co"># With rotation.</span>
x2 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> log_dmvnorm, <span class="dt">sigma =</span> covmat, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>))
<span class="co">#&gt; [1] &quot;optim&quot;</span>
<span class="kw">c</span>(x1$pa, x2$pa)
<span class="co">#&gt; [1] 0.2348134 0.5319432</span></code></pre></div>
<p>The probability of acceptance is increased by the rotation of axes. These plots show why.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(x1, <span class="dt">ru_scale =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(x2, <span class="dt">ru_scale =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAxlBMVEUAAAAAACsAADoAAEwAAGYAK2sAOjoAOpAATIcAZrYrAAArACsrAEwrKysrK2srTIcra6M6AAA6ADo6kNtMAABMACtMAExMK2tMTExMa2tMa6NMh75RDShmAABmtv9rKwBrKytrK0xrTCtra6Nro4dro76HTACHTCuHh0yHh4eHvqOHvr6QOgCQZgCQ2/+jayujo76jvoejvr62ZgC2//++h0y+o2u+o6O+voe+vqO+vr7bkDrb////tmb/25D//7b//9v///+eqXG8AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAK5UlEQVR4nO2dC1vcxhWGp04cY7dxcOwkTYlD3AbiFmIaKFuYNTb6/38qGmnukvab0WWl3f3ex14WPIxHL2fOXCQhUZCNiLkbsHQoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCgj6BPr37urG5nmELQ57eu/i//N7i6LSOl9D6bRFDxIF6rD5siKKe6rSL1X800gsoYevaxTVB+5G4b6b0qJhJUFDdPPuxkBG1NULEWryloI59efbWDgraUgyoeL8UOCtrKKLb16nqjbYRSfA5ckO5PUbfyOWxBOiPbxGwCyQsoCnLdzAaSH1AUpPx41J70++LQBUVydCfTimp/By1IxlRfK7So2tChCqoixXAuxEn1ovOR1IF0wIKkHz63R/L+p/fly7uLsLcdriATJVIIUQo6LoPo7+rlxMvVdVc7QEE6DVdyRCVj9beL1Ysf1UslSNjOl9XQ/RBkI8TIqQ29ePrPs+qlFmQzdE5D90KQjo3ATtXF7r5/r14ujCA3lz4oQSbvRIP73ZtyAKtenJ/8hu62IDPHiYKn3v0NdQmTfTIbuquCbDqJg8epiZwdliA9OQ6DpxE3In7bo6F5R7QuW1DtJq7nPS9mNjK8MGn0qUCQztA9Gpp1ROsnH4rPb58XMwsyoeD0tNlxYVO9KQI/0wh6vHxdvT77OKsgL9u0JJu2CDIf+zQ079RzvVl/8+xjJGibJw71jBkET4ugYksRVHLzfJYIqmNAryegHc9PYRfx+Q3Ny0Fay+e3c1y8oHuJLITVs8GO9WNKhdv3k41idSd7vNyyIJNC1HGmBI8nxhbr19DdmAeZ0zj2uAM7V+KoM4CEcHPKXg3dCUF2E952Lufmi/+cHsv/Xzes2YJmn7VnQxcvyGYPLyiMiHNxfHt098N1KCX2U8hG/OyRIL3ccrPCKPX8dqbW6385a/ez/4LMcrSpp46j1cvru39V28+BIL8jtvrZI0FSSi964tmh2neuPTX8iHr605aAchq6dEGVn9qHty61mhSnJ/Lq2AsgLbM2s+dXd7R0LhFMos9PpLg/FbGfoi7e7WcPBEnTP8LcEw1kVyd2wtySfjqvDtoDQXbaLBpREw1kLQJ1+IzS0CUKki56mnriJYZLOK7Ixs6V2dAFCnJTn/Dg27pY1KP0NxTQzy4L0tPmIkzOXvTYMIkDyHzDhksT8xu6LEHSnNtrjF3mE9H4ije+2fgZsaGLEmTPVRSieei1niD3+IWc0HEbuiRBdr/Qn+u165G2l0Xhk9C78hq6LEEyWFfYIxf1y201IZRGVeDHZJ9irwVFfSWKnnJFqpYUwgsnPyEVQk8Oxm1o3hE9Xm68nW4MQX7v8vRcV7Pm+3cXxk+zD+qF6ZyC1kKf1ngwbwZVF9ERPurv6q9n9cr9SnhdLMjO5tKWND8Tn/YpVakb6wZWV2P7hD4D2ta77t+9P5LqOh8hvjHhEw33dtcx8b+d9MRhycNYJw7tD11dWBmnXRNC9/+tLsQsw+eu7GvBPLH+liI1N7sWj16wmCSC7E0DsjN86n8s07MQp+piqJbwkcm5Ob+hmTlIh9BoOcgJ6gwfb/UlQmnBQJb5H080ipkbwzvip6egOBbsEOWGKyHOlSK/d9mVqcxIPfkNnXseZC6Cao7a4WzZjWhRqfbTXuM1dG5B3eFjY8dGTpyc632xfDlZDZ1bUKAkOHK78BJuFR9Nffokn9yGzitIHV9jzRDuk/nL9kCPCZ99jiA3N5SxH9fB2nKPW9jvtaB4bhjI+neVfewZ06CINLk5Y23Rt6GzCmrbUa5mzuWM8B/X6qqE82MvbMLelbf26t3QeQS19hZnq767QglS55TDHXrh6+mdoxcuKBbS+PS3X9+IE6Xp/pczbzRzxYveoZPV0JyC41VXHaCUomjxoz+cf3Fx992ZuhHOdS6TqYu+c8PshuYVHK26em1QtMaP3+OujlellasT74vCu215+oZmFhyruvq2SRH7se8sV+X66+j26bXrffaewa00NLfgWNVJb/Rqxo9m9aIMngt9YZQ/SxwjeBIbmltwpOqkdyGvExIJUl3rKM49GTvyYzQ0u+A41XVcbChCO957/5+ztw0HNDS/4CjVeYcbBE24MI3em/AZJTknNrRHwVGqq+5Yb+tVZku7IU24RemIHWypgqRdfTXSckR8qZT5vSRbamifgmNUZ/Mz8OPp8e7SGNPPkgS5I3NiNvmJrreT9u7dqRs6sODmWrrPi3n3oSQJ8hfuLvGMHD8LiiA3+fXFdAkKo2fcpoGGDi7YszrTS6TXwUI/5+IotNP3VNewhg4u2LM67cZPQO7N6sXTP96cmJuZwj7WfovFdA0dXLBndUZQEDf63erl9errl/ZmJhNFQ3dT+zV0cMGe1Xm/MauxtFCXQ6kTpvXNTNqOKVJ/82QsR5CZykRrC/WZ+h1ap0f2Zia3IjWrrkMQ1BpAGrU3/+M3VVczCdrc/TZ1D1uYoKLVT8WtuqDFXD5npoTD9uN7NnRowb7VmQvn2wSdV7/Fr752tZheyuaGDi3Yuzq90eX2dLw+5q/fx21Ij4YOLNi/uo4UJOaz09HQYQV7VyfN1fNeBEVbP5Om4+SGDizYuzqzWSHditaOWGYOeeCC/DPFftzYEY4R5G98FUXhC5rHz4IE2aWVdLNj28HGOxGYy6IEhfObWM0cehYlSMYnbIwu82HcFiQyqaCsR9e0LhvMPmwxl59pBPV5vpgdq6IvT7TVnMw0EdTj+WLS+7MkJupiXc8XC6vz4+LABCU9XyzMLGZz+VAE4eeLxWPTnIN5NxOOYm3PF/NPHLYM3vPl4k6mHObB88XmnN2kM62gjrvpitYctLzoUcwpKB7FFhlNswryWGx/oyAABQEWs5o/xByUV90BjmJbrG46ZhO0M8wkKLfO9KKTVLrtyvLrpKDRilLQHJVuu7L8OilotKIUNEel264sv04KGq3oPgnaKygIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBBgIkE3nb9QOaB6iED3iWzLgxBPPiT9x6k1JjONoIfu3zjt83hZHvZaPIfVlcUekgyl1pjOJII+v00TVF/s2PXcaEt9tcRNylEn1pjBJILWz35P62IVMDayjzot2tKYQtCnbz8k5qCKG3TkZX1F40EMg2rMYAJBqkdkCOp8gIArUQVEeljgGjOYQJB6pES6oIe0HJ0hKKHGDMYXVHWIZEEpP+28LjZq/IwsaK3mIGt9fUnntdSuqPe0oE1kJemkGjOYd6K4BhprMob5xBozmFXQp1dpP+30iWJqjenMKkj3Rnzo69SlRnKNyXCxCqAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEOBPCoUVIpryPD0AAAAASUVORK5CYII=" alt /><img src="data:image/png;base64,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" alt /></p>
<p>The three-dimensional case. Note: <code>plot.ru</code> doesn’t work when <code>d</code> is greater than <span class="math inline">\(2\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># three-dimensional normal with positive association ----------------</span>
covmat &lt;-<span class="st"> </span><span class="kw">matrix</span>(rho, <span class="dv">3</span>, <span class="dv">3</span>) +<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span> -<span class="st"> </span>rho, <span class="dv">3</span>)
<span class="co"># No rotation.  Slow !</span>
x3 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> log_dmvnorm, <span class="dt">sigma =</span> covmat, <span class="dt">d =</span> <span class="dv">3</span>, <span class="dt">n =</span> n,
  <span class="dt">init =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="dt">rotate =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; [1] &quot;optim&quot;</span>
<span class="co"># With rotation.</span>
x4 &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> log_dmvnorm, <span class="dt">sigma =</span> covmat, <span class="dt">d =</span> <span class="dv">3</span>, <span class="dt">n =</span> n,
  <span class="dt">init =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))
<span class="co">#&gt; [1] &quot;optim&quot;</span>
<span class="kw">c</span>(x3$pa, x4$pa)
<span class="co">#&gt; [1] 0.05320253 0.31279324</span></code></pre></div>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-BC1964">
<p>Box, G. E. P., and D. R. Cox. 1964. “An Analysis of Transformations.” <em>Journal of the Royal Statistical Society. Series B (Methodological)</em> 26 (2). Wiley for the Royal Statistical Society: 211–52. <a href="http://www.jstor.org/stable/2984418" class="uri">http://www.jstor.org/stable/2984418</a>.</p>
</div>
<div id="ref-NA2016">
<p>Northrop, P. J., and N. Attalides. 2016. “Posterior Propriety in Bayesian Extreme Value Analyses Using Reference Priors.” <em>Statistica Sinica</em> 26 (2): 721–43. doi:<a href="https://doi.org/10.5705/ss.2014.034">10.5705/ss.2014.034</a>.</p>
</div>
<div id="ref-NAJ2016">
<p>Northrop, P. J., N. Attalides, and P. Jonathan. 2016. “Cross-Validatory Extreme Value Threshold Selection and Uncertainty with Application to Ocean Storm Severity.” <em>Journal of the Royal Statistical Society: Series C (Applied Statistics)</em>. doi:<a href="https://doi.org/10.1111/rssc.12159">10.1111/rssc.12159</a>.</p>
</div>
<div id="ref-Stephenson2016">
<p>Stephenson, A. 2016. “Bayesian Inference for Extreme Value Modelling.” In <em>Extreme Value Modeling and Risk Analysis: Methods and Applications</em>, edited by D. K. Dey and J. Yan, 257–80. London: Chapman; Hall. doi:<a href="https://doi.org/10.1201/b19721-14">10.1201/b19721-14</a>.</p>
</div>
<div id="ref-evdbayes">
<p>Stephenson, A., and M. Ribatet. 2014. <em>Evdbayes: Bayesian Analysis in Extreme Value Theory</em>. <a href="https://CRAN.R-project.org/package=evdbayes" class="uri">https://CRAN.R-project.org/package=evdbayes</a>.</p>
</div>
<div id="ref-WGS1991">
<p>Wakefield, J. C., A. E. Gelfand, and A. F. M. Smith. 1991. “Efficient Generation of Random Variates via the Ratio-of-Uniforms Method.” <em>Statistics and Computing</em> 1 (2): 129–33. doi:<a href="https://doi.org/10.1007/BF01889987">10.1007/BF01889987</a>.</p>
</div>
<div id="ref-WSRG1994">
<p>Wakefield, J. C., A. F. M. Smith, A. Racine-Poon, and A. E. Gelfand. 1994. “Bayesian Analysis of Linear and Non-Linear Population Models by Using the Gibbs Sampler.” <em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em> 43 (1): 201–21. doi:<a href="https://doi.org/10.2307/2986121">10.2307/2986121</a>.</p>
</div>
<div id="ref-WH1931">
<p>Wilson, E. B., and M. M. Hilferty. 1931. “The Distribution of Chi-Square.” <em>Proc. Natl. Acad. Sci. USA</em> 17 (12): 684–88. <a href="http://www.jstor.org/stable/86022" class="uri">http://www.jstor.org/stable/86022</a>.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
